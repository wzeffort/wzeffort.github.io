# 用于构建和部署Hugo网站到GitHub Pages的示例工作流程
name: 发布Hugo网站到Pages

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      HUGO_VERSION: 0.139.3
    steps:
      - name: 安装Hugo CLI
        run: |
          wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \
          && sudo dpkg -i ${{ runner.temp }}/hugo.deb
      - name: 安装Dart Sass
        run: sudo snap install dart-sass
      - name: 检出 主题 分支
        uses: actions/checkout@v4
        with:
          ref: taichi
          submodules: recursive
          fetch-depth: 0
      - name: 检出 main 分支到 ./content/posts
        uses: actions/checkout@v4
        with:
          ref: main
          path: ./content/posts
          submodules: recursive
          fetch-depth: 0
      - name: 设置Pages
        id: pages
        uses: actions/configure-pages@v3
      - name: 安装Node.js依赖
        run: "[[ -f package-lock.json || -f npm-shrinkwrap.json ]] && npm ci || true"
      - name: 使用Hugo构建
        env:
          HUGO_ENVIRONMENT: production
          HUGO_ENV: production
        run: |
          hugo \
            --gc \
            --minify \
            --baseURL "${{ steps.pages.outputs.base_url }}/"
      - name: 检测ADMIN_API_KEY是否存在
        run: |
          if [ -z "$ADMIN_API_KEY" ]; then
            echo "ADMIN_API_KEY 未设置或为空"
            exit 1
          else
            echo "ADMIN_API_KEY 已设置（非空）"
            # 如果需要进一步确认长度（不暴露内容）
            echo "ADMIN_API_KEY 长度：${#ADMIN_API_KEY}"
          fi
        env:
          ADMIN_API_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}
      - name: 上传Algolia索引
        run: |
          # 安装依赖
          npm install algoliasearch

          echo "APPLICATION_ID: $APPLICATION_ID"
          echo "ADMIN_API_KEY: $ADMIN_API_KEY"
          echo "INDEX_NAME: $INDEX_NAME"
          echo "FILE_PATH: $FILE_PATH"

          # 输出脚本
          cat > uploadToAlgolia.js << 'EOF'
          const { algoliasearch } = require('algoliasearch');
          const fs = require('fs');
          const path = require('path');

          const APPLICATION_ID = process.env.APPLICATION_ID;
          const ADMIN_API_KEY = process.env.ADMIN_API_KEY;
          const INDEX_NAME = process.env.INDEX_NAME;
          const FILE_PATH = process.env.FILE_PATH;

          // 初始化Algolia客户端
          const client = algoliasearch(APPLICATION_ID, ADMIN_API_KEY);

          // 读取索引文件
          const filePath = path.resolve(FILE_PATH);

          console.log('Reading file:', filePath);

          fs.readFile(filePath, 'utf8', async (err, data) => {
            if (err) {
              console.error('Error reading file:', err);
              return;
            }

            try {
              const objects = JSON.parse(data);

              // 上传记录到Algolia
              const response = await client.saveObjects({indexName: INDEX_NAME, objects: objects, waitForTasks: true});
              console.log('Records uploaded successfully:', response);
            } catch (parseError) {
              console.error('Error parsing JSON file:', parseError);
            }
          });
          EOF

          # 执行脚本
          node uploadToAlgolia.js
        env:
          APPLICATION_ID: "68EZJSYL8I"
          ADMIN_API_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}
          INDEX_NAME: "shokaX"
          FILE_PATH: "./public/algolia.json"
      - name: 上传构建产物
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./public

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: 部署到GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: 设置Node.js环境
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: 创建缓存刷新脚本
        run: |
          cat > purge-edgeone-hostname.js <<EOF
          const crypto = require('crypto');

          function sha256(message, secret, encoding) {
              const hmac = crypto.createHmac('sha256', secret);
              return hmac.update(message).digest(encoding);
          }

          function getHash(message, encoding = 'hex') {
              const hash = crypto.createHash('sha256');
              return hash.update(message).digest(encoding);
          }

          function getDate(timestamp) {
              const date = new Date(timestamp * 1000);
              return date.toISOString().slice(0, 10).replace(/-/g, '-');
          }

          async function purgeHostname() {
              try {
                  // 环境变量配置
                  const SECRET_ID = process.env.TENCENT_SECRET_ID;
                  const SECRET_KEY = process.env.TENCENT_SECRET_KEY;
                  const ZONE_ID = process.env.EDGEONE_ZONE_ID;
                  const HOSTNAMES = process.env.EDGEONE_HOSTNAMES.split(',');

                  // API 参数配置
                  const endpoint = "teo.tencentcloudapi.com";
                  const service = "teo";
                  const region = "ap-guangzhou";
                  const action = "CreatePurgeTask";
                  const version = "2022-09-01";
                  const timestamp = Math.floor(Date.now() / 1000);
                  const date = getDate(timestamp);

                  // 构造请求体
                  const payload = JSON.stringify({
                      ZoneId: ZONE_ID,
                      Type: "purge_host",
                      Targets: HOSTNAMES
                  });

                  // ************* 签名计算部分 *************
                  // 步骤1：规范请求
                  const httpRequestMethod = "POST";
                  const canonicalUri = "/";
                  const canonicalQueryString = "";
                  const canonicalHeaders = [
                      \`content-type:application/json; charset=utf-8\`,
                      \`host:\${endpoint}\`,
                      \`x-tc-action:\${action.toLowerCase()}\`
                  ].join('\\n') + '\\n';
                  const signedHeaders = "content-type;host;x-tc-action";
                  const hashedRequestPayload = getHash(payload);

                  const canonicalRequest = [
                      httpRequestMethod,
                      canonicalUri,
                      canonicalQueryString,
                      canonicalHeaders,
                      signedHeaders,
                      hashedRequestPayload
                  ].join('\\n');

                  // 步骤2：待签字符串
                  const algorithm = "TC3-HMAC-SHA256";
                  const hashedCanonicalRequest = getHash(canonicalRequest);
                  const credentialScope = \`\${date}/\${service}/tc3_request\`;
                  const stringToSign = [
                      algorithm,
                      timestamp,
                      credentialScope,
                      hashedCanonicalRequest
                  ].join('\\n');

                  // 步骤3：计算签名
                  const kDate = sha256(date, 'TC3' + SECRET_KEY);
                  const kService = sha256(service, kDate);
                  const kSigning = sha256('tc3_request', kService);
                  const signature = sha256(stringToSign, kSigning, 'hex');

                  // 步骤4：构造Authorization头
                  const authorization = \`\${algorithm} Credential=\${SECRET_ID}/\${credentialScope}, SignedHeaders=\${signedHeaders}, Signature=\${signature}\`;

                  // 发送API请求
                  const response = await fetch(\`https://\${endpoint}\`, {
                      method: 'POST',
                      headers: {
                          'Authorization': authorization,
                          'Content-Type': 'application/json; charset=utf-8',
                          'Host': endpoint,
                          'X-TC-Action': action,
                          'X-TC-Timestamp': timestamp.toString(),
                          'X-TC-Version': version,
                          'X-TC-Region': region
                      },
                      body: payload
                  });

                  const result = await response.json();
                  
                  if (!response.ok) {
                      throw new Error(\`API请求失败: \${JSON.stringify(result.Response)}\`);
                  }

                  // 检查失败列表
                  if (result.Response.FailedList?.length > 0) {
                      console.error('部分Host刷新失败:', result.Response.FailedList);
                      process.exit(1);
                  }

                  console.log('Hostname刷新成功:', {
                      JobId: result.Response.JobId,
                      RequestId: result.Response.RequestId
                  });

              } catch (error) {
                  // 网络错误处理
                  if (error.code === 'ENOTFOUND') {
                      console.error('DNS解析失败，请检查endpoint配置');
                  }
                  // 签名错误处理
                  if (error.message.includes('AuthFailure')) {
                      console.error('凭证验证失败，请检查SecretId/SecretKey');
                  }
                  // 业务逻辑错误
                  if (error.Response?.Error) {
                      console.error(\`API错误: [\${error.Response.Error.Code}] \${error.Response.Error.Message}\`);
                  }
                  console.error('❌ 刷新操作失败:', error.message);
                  process.exit(1);
              }
          }

          purgeHostname();
          EOF

      - name: 执行Hostname缓存刷新
        env:
          TENCENT_SECRET_ID: ${{ secrets.TENCENT_SECRET_ID }}
          TENCENT_SECRET_KEY: ${{ secrets.TENCENT_SECRET_KEY }}
          EDGEONE_ZONE_ID: ${{ secrets.EDGEONE_ZONE_ID }}
          EDGEONE_HOSTNAMES: ${{ secrets.EDGEONE_HOSTNAMES }}
        run: node purge-edgeone-hostname.js
